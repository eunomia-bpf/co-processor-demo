#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <CL/cl.h>
#include <sys/time.h>
#include <math.h>

#define VECTOR_SIZE 1000000
#define KERNEL_NAME "vector_add"

// Function to read binary file contents
unsigned char* read_binary_file(const char* filename, size_t* size) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        printf("Failed to open file: %s\n", filename);
        exit(1);
    }

    fseek(file, 0, SEEK_END);
    *size = ftell(file);
    fseek(file, 0, SEEK_SET);

    unsigned char* binary = (unsigned char*)malloc(*size);
    if (!binary) {
        printf("Memory allocation failed\n");
        fclose(file);
        exit(1);
    }

    size_t read = fread(binary, 1, *size, file);
    if (read != *size) {
        printf("Failed to read file: %s\n", filename);
        free(binary);
        fclose(file);
        exit(1);
    }

    fclose(file);
    return binary;
}

double get_time() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec + tv.tv_usec * 1e-6;
}

int main() {
    printf("LLVM IR to OpenCL via SPIR-V Example\n");
    
    // Initialize data
    float* a = (float*)malloc(sizeof(float) * VECTOR_SIZE);
    float* b = (float*)malloc(sizeof(float) * VECTOR_SIZE);
    float* c = (float*)malloc(sizeof(float) * VECTOR_SIZE);
    float* verify = (float*)malloc(sizeof(float) * VECTOR_SIZE);

    for(int i = 0; i < VECTOR_SIZE; i++) {
        a[i] = rand() / (float)RAND_MAX;
        b[i] = rand() / (float)RAND_MAX;
    }

    // Read SPIR-V binary directly from file generated by LLVM tools
    size_t binary_size = 0;
    unsigned char* binary = read_binary_file("vector_add.spv", &binary_size);
    printf("Read SPIR-V binary, size: %zu bytes\n", binary_size);

    // Get platform
    cl_platform_id platform;
    cl_uint num_platforms;
    cl_int err = clGetPlatformIDs(1, &platform, &num_platforms);
    if (err != CL_SUCCESS) {
        printf("Failed to get OpenCL platform: %d\n", err);
        return 1;
    }
    printf("Found %d platform(s)\n", num_platforms);

    // Get device
    cl_device_id device;
    cl_uint num_devices;
    err = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 1, &device, &num_devices);
    if (err != CL_SUCCESS) {
        printf("Failed to get OpenCL device: %d\n", err);
        return 1;
    }
    printf("Found %d device(s)\n", num_devices);

    // Check if device supports SPIR-V
    char extensions[4096];
    clGetDeviceInfo(device, CL_DEVICE_EXTENSIONS, sizeof(extensions), extensions, NULL);
    if (strstr(extensions, "cl_khr_il_program") == NULL) {
        printf("Warning: Device does not explicitly support SPIR-V (cl_khr_il_program).\n");
        printf("Falling back to compatibility mode. This may not work on all devices.\n");
    }

    // Display device info
    char device_name[256];
    clGetDeviceInfo(device, CL_DEVICE_NAME, sizeof(device_name), device_name, NULL);
    printf("Using device: %s\n", device_name);

    // Create context
    cl_context context = clCreateContext(NULL, 1, &device, NULL, NULL, &err);
    if (err != CL_SUCCESS) {
        printf("Failed to create OpenCL context: %d\n", err);
        return 1;
    }

    // Create command queue
    cl_queue_properties properties[] = {CL_QUEUE_PROPERTIES, 0, 0};
    cl_command_queue queue = clCreateCommandQueueWithProperties(context, device, properties, &err);
    if (err != CL_SUCCESS) {
        printf("Failed to create command queue: %d\n", err);
        return 1;
    }

    // Create memory buffers
    cl_mem a_mem = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(float) * VECTOR_SIZE, NULL, &err);
    cl_mem b_mem = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(float) * VECTOR_SIZE, NULL, &err);
    cl_mem c_mem = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(float) * VECTOR_SIZE, NULL, &err);

    // Copy input data to device
    err = clEnqueueWriteBuffer(queue, a_mem, CL_TRUE, 0, sizeof(float) * VECTOR_SIZE, a, 0, NULL, NULL);
    err |= clEnqueueWriteBuffer(queue, b_mem, CL_TRUE, 0, sizeof(float) * VECTOR_SIZE, b, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        printf("Failed to write to device buffer: %d\n", err);
        return 1;
    }

    // Create program from SPIR-V binary
    cl_program program = NULL;
    
    // Try to use clCreateProgramWithIL for OpenCL 2.1+ devices
    cl_int il_error = CL_SUCCESS;
    // Get OpenCL version
    char version[256];
    clGetDeviceInfo(device, CL_DEVICE_VERSION, sizeof(version), version, NULL);
    printf("OpenCL version: %s\n", version);
    
    // Check if we can use clCreateProgramWithIL
    // First try with direct function call if available
    void* clCreateProgramWithILFn = clGetExtensionFunctionAddressForPlatform(platform, "clCreateProgramWithIL");
    if (clCreateProgramWithILFn || strstr(extensions, "cl_khr_il_program")) {
        program = clCreateProgramWithIL(context, binary, binary_size, &il_error);
        if (il_error == CL_SUCCESS) {
            printf("Created program from SPIR-V using clCreateProgramWithIL\n");
        }
    }
    
    // Fallback to binary if IL loading fails or is not supported
    if (program == NULL || il_error != CL_SUCCESS) {
        printf("Falling back to clCreateProgramWithBinary\n");
        program = clCreateProgramWithBinary(context, 1, &device, &binary_size, 
                                         (const unsigned char**)&binary, NULL, &err);
        if (err != CL_SUCCESS) {
            printf("Failed to create program with binary: %d\n", err);
            return 1;
        }
        printf("Created program from binary using clCreateProgramWithBinary\n");
    }

    // Build the program
    err = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
    if (err != CL_SUCCESS) {
        // Get build log
        size_t log_size;
        clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
        char* log = (char*)malloc(log_size);
        clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log, NULL);
        printf("Build error:\n%s\n", log);
        free(log);
        return 1;
    }
    printf("Program built successfully\n");

    // Create kernel
    cl_kernel kernel = clCreateKernel(program, KERNEL_NAME, &err);
    if (err != CL_SUCCESS) {
        printf("Failed to create kernel: %d\n", err);
        return 1;
    }

    // Set kernel arguments
    err = clSetKernelArg(kernel, 0, sizeof(cl_mem), &a_mem);
    err |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &b_mem);
    err |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &c_mem);
    unsigned int vector_size = VECTOR_SIZE;
    err |= clSetKernelArg(kernel, 3, sizeof(unsigned int), &vector_size);
    if (err != CL_SUCCESS) {
        printf("Failed to set kernel arguments: %d\n", err);
        return 1;
    }

    // Execute kernel
    size_t global_size = VECTOR_SIZE;
    double start_time = get_time();
    err = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &global_size, NULL, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        printf("Failed to execute kernel: %d\n", err);
        return 1;
    }
    
    clFinish(queue);
    double gpu_time = get_time() - start_time;
    printf("OpenCL kernel executed\n");

    // Read result
    err = clEnqueueReadBuffer(queue, c_mem, CL_TRUE, 0, sizeof(float) * VECTOR_SIZE, c, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        printf("Failed to read from device: %d\n", err);
        return 1;
    }

    // Verify result
    start_time = get_time();
    for(int i = 0; i < VECTOR_SIZE; i++) {
        verify[i] = a[i] + b[i];
    }
    double cpu_time = get_time() - start_time;

    // Check results
    int correct = 1;
    for(int i = 0; i < VECTOR_SIZE; i++) {
        if(fabs(verify[i] - c[i]) > 1e-5) {
            correct = 0;
            printf("Mismatch at position %d: CPU=%f, GPU=%f\n", i, verify[i], c[i]);
            break;
        }
    }

    printf("\nResults:\n");
    printf("Vector addition of size %d\n", VECTOR_SIZE);
    printf("GPU Time: %f seconds\n", gpu_time);
    printf("CPU Time: %f seconds\n", cpu_time);
    printf("Verification: %s\n", correct ? "PASSED" : "FAILED");
    printf("Speedup: %fx\n", cpu_time / gpu_time);

    // Cleanup
    clReleaseMemObject(a_mem);
    clReleaseMemObject(b_mem);
    clReleaseMemObject(c_mem);
    clReleaseKernel(kernel);
    clReleaseProgram(program);
    clReleaseCommandQueue(queue);
    clReleaseContext(context);
    
    free(a);
    free(b);
    free(c);
    free(verify);
    free(binary);

    return 0;
} 